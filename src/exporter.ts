import * as vscode from 'vscode';
import * as path from 'path';
import { GraphData } from './types';

export async function handleExportIndex(graphData: GraphData, folderPath: string): Promise<void> {
  const content = generateIndexMarkdown(graphData, folderPath);

  const defaultUri = vscode.Uri.file(path.join(folderPath, '_map.md'));
  const uri = await vscode.window.showSaveDialog({
    defaultUri,
    filters: { 'Markdown': ['md'] },
    title: 'Export Agent Context Graph Index',
  });

  if (uri) {
    await vscode.workspace.fs.writeFile(uri, Buffer.from(content, 'utf-8'));
    vscode.window.showInformationMessage(`Index exported to ${path.basename(uri.fsPath)}`);
  }
}

export async function handleExportJson(graphData: GraphData, _folderPath: string): Promise<void> {
  const clean = cleanGraphDataForExport(graphData);
  const json = JSON.stringify(clean, null, 2);

  const uri = await vscode.window.showSaveDialog({
    filters: { 'JSON': ['json'] },
    title: 'Export Agent Context Graph JSON',
  });

  if (uri) {
    await vscode.workspace.fs.writeFile(uri, Buffer.from(json, 'utf-8'));
    vscode.window.showInformationMessage(`Graph exported to ${path.basename(uri.fsPath)}`);
  }
}

function generateIndexMarkdown(graphData: GraphData, folderPath: string): string {
  const lines: string[] = [];
  const folderName = path.basename(folderPath);

  lines.push(`# ${folderName} — Agent Context Graph Index`);
  lines.push('');
  lines.push(`> Auto-generated documentation map. Health score: **${graphData.globalHealthScore}/100**`);
  lines.push(`> Total documents: ${graphData.nodes.length} | Total token estimate: ~${graphData.totalTokenEstimate.toLocaleString()}`);
  lines.push('');

  // Hub documents (top 5 by degree)
  const hubs = [...graphData.nodes]
    .sort((a, b) => (b.inDegree + b.outDegree) - (a.inDegree + a.outDegree))
    .slice(0, 5);

  if (hubs.length > 0) {
    lines.push('## Hub Documents');
    lines.push('');
    for (const hub of hubs) {
      lines.push(`- **[${hub.label}](${hub.relativePath})** — ${hub.inDegree + hub.outDegree} connections, health: ${hub.healthScore}/100`);
    }
    lines.push('');
  }

  // Group by category
  const categories = new Map<string, typeof graphData.nodes>();
  for (const node of graphData.nodes) {
    if (!categories.has(node.category)) { categories.set(node.category, []); }
    categories.get(node.category)!.push(node);
  }

  lines.push('## Documents by Category');
  lines.push('');

  for (const [cat, nodes] of [...categories.entries()].sort()) {
    lines.push(`### ${cat}`);
    lines.push('');
    const sorted = [...nodes].sort((a, b) => a.label.localeCompare(b.label));
    for (const node of sorted) {
      const warnings = node.warnings.length > 0 ? ` (${node.warnings.length} warnings)` : '';
      lines.push(`- [${node.label}](${node.relativePath}) — ~${node.tokenEstimate} tokens, health: ${node.healthScore}/100${warnings}`);
    }
    lines.push('');
  }

  // Broken links
  if (graphData.brokenLinks.length > 0) {
    lines.push('## Broken Links');
    lines.push('');
    for (const bl of graphData.brokenLinks) {
      lines.push(`- **${bl.sourceLabel}**: links to missing \`${path.basename(bl.targetPath)}\``);
    }
    lines.push('');
  }

  // Health breakdown
  lines.push('## Health Breakdown (Global Averages)');
  lines.push('');
  const gb = graphData.globalHealthBreakdown;
  lines.push(`| Metric | Score | Max |`);
  lines.push(`|--------|-------|-----|`);
  lines.push(`| Has H1 Title | ${gb.hasTitle} | 10 |`);
  lines.push(`| Has Overview | ${gb.hasOverview} | 15 |`);
  lines.push(`| Has Outgoing Links | ${gb.hasOutgoingLinks} | 15 |`);
  lines.push(`| Has Incoming Links | ${gb.hasIncomingLinks} | 15 |`);
  lines.push(`| Adequate Length | ${gb.adequateLength} | 10 |`);
  lines.push(`| Has Related Section | ${gb.hasRelatedSection} | 10 |`);
  lines.push(`| No Broken Links | ${gb.noBrokenLinks} | 10 |`);
  lines.push(`| Bidirectional Ratio | ${gb.bidirectionalRatio} | 15 |`);
  lines.push('');

  lines.push('---');
  lines.push('*Generated by Agent Context Graph Visualizer*');

  return lines.join('\n');
}

function cleanGraphDataForExport(graphData: GraphData): object {
  return {
    nodes: graphData.nodes.map(n => ({
      id: n.id,
      label: n.label,
      summary: n.summary,
      category: n.category,
      filePath: n.filePath,
      relativePath: n.relativePath,
      inDegree: n.inDegree,
      outDegree: n.outDegree,
      tokenEstimate: n.tokenEstimate,
      contentWordCount: n.contentWordCount,
      keywords: n.keywords,
      healthScore: n.healthScore,
      healthBreakdown: n.healthBreakdown,
      warnings: n.warnings,
      bidirectionalRatio: n.bidirectionalRatio,
    })),
    edges: graphData.edges.map(e => ({
      source: typeof e.source === 'string' ? e.source : (e.source as unknown as { id: string }).id,
      target: typeof e.target === 'string' ? e.target : (e.target as unknown as { id: string }).id,
      label: e.label,
      type: e.type,
    })),
    brokenLinks: graphData.brokenLinks,
    backlinkSuggestions: graphData.backlinkSuggestions,
    similaritySuggestions: graphData.similaritySuggestions,
    globalHealthScore: graphData.globalHealthScore,
    globalHealthBreakdown: graphData.globalHealthBreakdown,
    totalTokenEstimate: graphData.totalTokenEstimate,
  };
}
